{
  "en-US": {
    "steps": {
      "formatValidationLabel": "Format validation",
      "formatValidationLabelPending": "Validating format",
      "hashComparisonLabel": "Hash comparison",
      "hashComparisonLabelPending": "Comparing hash",
      "statusCheckLabel": "Status check",
      "statusCheckLabelPending": "Checking record status"
    },
    "subSteps": {
      "getTransactionIdLabel": "Get transaction ID",
      "getTransactionIdLabelPending": "Getting transaction ID",
      "computeLocalHashLabel": "Compute local hash",
      "computeLocalHashLabelPending": "Computing local hash",
      "fetchRemoteHashLabel": "Fetch remote hash",
      "fetchRemoteHashLabelPending": "Fetching remote hash",
      "getIssuerProfileLabel": "Get issuer profile",
      "getIssuerProfileLabelPending": "Getting issuer profile",
      "parseIssuerKeysLabel": "Parse issuer keys",
      "parseIssuerKeysLabelPending": "Parsing issuer keys",
      "compareHashesLabel": "Compare hashes",
      "compareHashesLabelPending": "Comparing hashes",
      "checkMerkleRootLabel": "Check Merkle Root",
      "checkMerkleRootLabelPending": "Checking Merkle Root",
      "checkReceiptLabel": "Check Receipt",
      "checkReceiptLabelPending": "Checking Receipt",
      "checkIssuerSignatureLabel": "Check Issuer Signature",
      "checkIssuerSignatureLabelPending": "Checking Issuer Signature",
      "checkAuthenticityLabel": "Check Authenticity",
      "checkAuthenticityLabelPending": "Checking Authenticity",
      "checkRevokedStatusLabel": "Check Revoked Status",
      "checkRevokedStatusLabelPending": "Checking Revoked Status",
      "checkExpiresDateLabel": "Check Expiration Date",
      "checkExpiresDateLabelPending": "Checking Expiration Date"
    },
    "revocation": {
      "preReason": "Reason given:",
      "reason": "This certificate has been revoked by the issuer."
    },
    "success": {
      "mocknet": "This mock Blockcert passed all checks. Mocknet mode is only used for issuers to test their workflow locally. This Blockcert was not recorded on a blockchain, and it should not be considered a verified Blockcert.",
      "blockchain": "Success"
    },
    "errors": {
      "certificateNotValid": "This is not a valid certificate",
      "getChain": "Didn't recognize chain value",
      "getTransactionId": "Cannot verify this certificate without a transaction ID to compare against.",
      "getIssuerProfile": "Unable to get issuer profile",
      "getRevokedAssertions": "Unable to get revocation assertions",
      "lookForTxInvalidChain": "Invalid chain; does not map to known BlockchainExplorers.",
      "lookForTxInvalidAppConfig": "Invalid application configuration; check the CONFIG.MinimumBlockchainExplorers configuration value",
      "lookForTxCouldNotConfirm": "Could not confirm the transaction. No blockchain apis returned a response. This could be because of rate limiting.",
      "lookForTxDifferentAddresses": "Issuing addresses returned by the blockchain APIs were different",
      "lookForTxDifferentRemoteHashes": "Remote hashes returned by the blockchain APIs were different",
      "parseIssuerKeys": "Unable to parse JSON out of issuer identification data.",
      "getBlockcypherFetcher": "Unable to get remote hash",
      "getChainSoFetcher": "Unable to get remote hash",
      "parseBlockCypherResponse": "Number of transaction confirmations were less than the minimum required, according to Blockcypher API",
      "parseChainSoResponse": "Number of transaction confirmations were less than the minimum required, according to Chain.so API",
      "checkEtherScanConfirmations": "Number of transaction confirmations were less than the minimum required, according to EtherScan API",
      "couldNotConfirmTx": "Could not confirm the transaction",
      "failedJsonLdNormalization": "Failed JSON-LD normalization",
      "foundUnmappedFields": "Found unmapped fields during JSON-LD normalization",
      "ensureHashesEqual": "Computed hash does not match remote hash",
      "ensureIssuerSignature": "Issuer key does not match derived address.",
      "ensureMerkleRootEqual": "Merkle root does not match remote hash.",
      "ensureNotExpired": "This certificate has expired.",
      "getCaseInsensitiveKey": "Transaction occurred at time when issuing address was not considered valid.",
      "ensureValidReceipt": "The receipt is malformed. There was a problem navigating the merkle tree in the receipt.",
      "invalidMerkleReceipt": "Invalid Merkle Receipt. Proof hash did not match Merkle root",
      "isTransactionIdValid": "Cannot verify this certificate without a transaction ID to compare against."
    }
  },
  "fr": {
    "steps": {
      "formatValidationLabel": "Validation du format",
      "formatValidationLabelPending": "Validation du format",
      "hashComparisonLabel": "Comparaison du hash",
      "hashComparisonLabelPending": "Comparaison du hash",
      "statusCheckLabel": "Vérification du status",
      "statusCheckLabelPending": "Vérification du status"
    },
    "subSteps": {
      "getTransactionIdLabel": "Obtention de l'identifiant de transaction",
      "getTransactionIdLabelPending": "Obtention de l'identifiant de transaction",
      "computeLocalHashLabel": "Calcul du hash local",
      "computeLocalHashLabelPending": "Calcul du hash local",
      "fetchRemoteHashLabel": "Récupération du hash distant",
      "fetchRemoteHashLabelPending": "Récupération du hash distant",
      "getIssuerProfileLabel": "Obtention du profil de l'émetteur",
      "getIssuerProfileLabelPending": "Obtention du profil de l'émetteur",
      "parseIssuerKeysLabel": "Traitement des clés de l'émetteur",
      "parseIssuerKeysLabelPending": "Traitement des clés de l'émetteur",
      "compareHashesLabel": "Comparaison des hash",
      "compareHashesLabelPending": "Comparaison des hashs",
      "checkMerkleRootLabel": "Vérification du Merkle Root",
      "checkMerkleRootLabelPending": "Vérification du  Merkle Root",
      "checkReceiptLabel": "Vérification du reçu",
      "checkReceiptLabelPending": "Vérification du reçu",
      "checkIssuerSignatureLabel": "Vérification de la signature de l'émetteur",
      "checkIssuerSignatureLabelPending": "Vérification de la signature de l'émetteur",
      "checkAuthenticityLabel": "Vérification de l'authenticité",
      "checkAuthenticityLabelPending": "Vérification de l'authenticité",
      "checkRevokedStatusLabel": "Vérification du status de révocation",
      "checkRevokedStatusLabelPending": "Vérification du status de révocation",
      "checkExpiresDateLabel": "Vérification de la date d'expiration",
      "checkExpiresDateLabelPending": "Vérification de la date d'expiration"
    },
    "revocation": {
      "preReason": "Raison :",
      "reason": "Ce certificat a été révoqué par l'émetteur."
    },
    "success": {
      "mocknet": "Ce Blockcert de test a été vérifié. Le mode Mocknet est utilisé uniquement par les émetteurs afin de tester leur pré-émission. Ce Blockcert n'a pas été enregistré sur une blockchain, et en tant que tel ne peut pas être considéré un Blockcert valide.",
      "blockchain": "Valide"
    },
    "errors": {
      "certificateNotValid": "Certificat invalide",
      "getChain": "Valeur de chaine non reconnue",
      "getTransactionId": "Impossible de vérifier ce certificat sans un identifiant de transaction valide",
      "getIssuerProfile": "Profil de l'émetteur indisponible",
      "getRevokedAssertions": "Impossible d'obtenir les raisons de revocation",
      "lookForTxInvalidChain": "Chaine invalide : non liée à un BlockchainExplorers connu",
      "lookForTxInvalidAppConfig": "Configuration de l'application invalide : vérifiez la valeur de configuration de CONFIG.MinimumBlockchainExplorers",
      "lookForTxCouldNotConfirm": "Impossible de confirmer la transaction. Aucune API blockchain n'a répondu. Potentiellement dû à une limite de débit réseau.",
      "lookForTxDifferentAddresses": "Les adresses d'émission reçues de l'API blockchain ne concordent pas",
      "lookForTxDifferentRemoteHashes": "Les hashs distants reçus de l'API blockchain ne concordent pas",
      "parseIssuerKeys": "Impossible de lire le JSON d'identification de l'émetteur",
      "getBlockcypherFetcher": "Impossible d'obtenir le hash distant",
      "getChainSoFetcher": "Impossible d'obtenir le hash distant",
      "parseBlockCypherResponse": "Le nombre de confirmations de transaction n'atteint pas le minimum requis, d'après l'API Blockcypher",
      "parseChainSoResponse": "Le nombre de confirmations de transaction n'atteint pas le minimum requis, d'après l'API Chain.so",
      "checkEtherScanConfirmations": "Le nombre de confirmations de transaction n'atteint pas le minimum requis, d'après l'API EtherScan",
      "couldNotConfirmTx": "Impossible de confirmer la transaction",
      "failedJsonLdNormalization": "Erreur de normalisation JSON-LD",
      "foundUnmappedFields": "Champs non liés découverts durant la normalisation JSON-LD",
      "ensureHashesEqual": "Calcul du hash local différent du hash distant",
      "ensureIssuerSignature": "La clé de l'émetteur ne correspond pas à l'adresse dérivée",
      "ensureMerkleRootEqual": "Le Merkle root ne correspond pas au hash distant",
      "ensureNotExpired": "Certificat expiré",
      "getCaseInsensitiveKey": "Transaction émise lorsque l'adresse de l'émetteur était considérée invalide",
      "ensureValidReceipt": "Erreur d'écriture du reçu. Un problème est survenu lors de la navigation de l'arbre Merkle du reçu.",
      "invalidMerkleReceipt": "Reçu Merkle invalid. Hash de preuve différent du Merkle root",
      "isTransactionIdValid": "Impossible de vérifier ce certificat sans un identifiant de transaction valide"
    }
  },
  "es-ES": {
    "steps": {
      "formatValidationLabel": "Validación de formato",
      "formatValidationLabelPending": "Validando el formato",
      "hashComparisonLabel": "Comparación de cadena binaria",
      "hashComparisonLabelPending": "Comparando cadena binaria",
      "statusCheckLabel": "Estado de Verificación",
      "statusCheckLabelPending": "Verificando Estado de Grabación"
    },
    "subSteps": {
      "getTransactionIdLabel": "Obtener Identificación de Transacción",
      "getTransactionIdLabelPending": "Obteniendo Identificación de Transacción",
      "computeLocalHashLabel": "Calcular cadena binaria local",
      "computeLocalHashLabelPending": "Calculando cadena binaria local",
      "fetchRemoteHashLabel": "Obtener cadena binaria remota",
      "fetchRemoteHashLabelPending": "Obeniendo cadena binaria remota",
      "getIssuerProfileLabel": "Obtener perfil de emisor",
      "getIssuerProfileLabelPending": "Obteniendo perfil de emisor",
      "parseIssuerKeysLabel": "Analizar claves del emisor",
      "parseIssuerKeysLabelPending": "Analizando claves del emisor",
      "compareHashesLabel": "Comparar cadenas binarias",
      "compareHashesLabelPending": "Comparando cadenas binarias",
      "checkMerkleRootLabel": "Verificar Merkle Root",
      "checkMerkleRootLabelPending": "Verificando Merkle Root",
      "checkReceiptLabel": "Verificar Recibo",
      "checkReceiptLabelPending": "Verificando Recibo",
      "checkIssuerSignatureLabel": "Verificar Firma del Emisor",
      "checkIssuerSignatureLabelPending": "Verificando Firma del Emisor",
      "checkAuthenticityLabel": "Verificar Autenticidad",
      "checkAuthenticityLabelPending": "Verificando Autenticidad",
      "checkRevokedStatusLabel": "Verificar Estado de Revocación",
      "checkRevokedStatusLabelPending": "Verificando Estado de Revocación",
      "checkExpiresDateLabel": "Verificar Fechas de Expiración",
      "checkExpiresDateLabelPending": "Verificando Fechas de Expiración"
    },
    "revocation": {
      "preReason": "Razón dada:",
      "reason": "Este certificado ha sido revocado por el emisor"
    },
    "success": {
      "mocknet": "Este Blockcert de prueba pasó todas los controles. El modo Mocknet es utilizado solamente para que los emisores prueben su flujo de trabajo localmente",
      "blockchain": "Éxito"
    },
    "errors": {
      "certificateNotValid": "Este no es un certificado válido",
      "getChain": "Valor de cadena no reconocido",
      "getTransactionId": "No se puede verificar este certificado sin una identificación de transacción que sirva como comparación",
      "getIssuerProfile": "No se ha podido obtener el perfil del emisor",
      "getRevokedAssertions": "No se ha podido obtener aseveraciones de revocación",
      "lookForTxInvalidChain": "Cadena inválida; no corresponde a BlockchainExplorers reconocidos",
      "lookForTxInvalidAppConfig": "Configuración de aplicación inválida; cheque el valor de configuración CONFIG.MinimumBlockchainExplorers",
      "lookForTxCouldNotConfirm": "No se ha podido confirmar la transacción. Ninguna del las APIs de blockchain generó una respuesta. Esto puede ser causado por limitaciones de tasa.",
      "lookForTxDifferentAddresses": "Las direcciones emisoras generadas por las APIs del blockchain son distintas",
      "lookForTxDifferentRemoteHashes": "Las cadenas binarias remotas generadas por las APIs del blockchain son distintas",
      "parseIssuerKeys": "No se ha podido analizar el JSON de la información de identificación del emisor",
      "getBlockcypherFetcher": "No se ha podido obtener la cadena binaria remota",
      "getChainSoFetcher": "No se ha podido obtener la cadena binaria remota",
      "parseBlockCypherResponse": "El número de transacciones confirmadas son menores que el mínimo requerido, de acuerdo al API Blockcypher",
      "parseChainSoResponse": "El número de transacciones confirmadas son menores que el mínimo requerido, de acuerdo al API Chain.so",
      "checkEtherScanConfirmations": "El número de transacciones confirmadas son menores que el mínimo requerido, de acuerdo al API EtherScan",
      "couldNotConfirmTx": "No se ha podido confirmar la transacción",
      "failedJsonLdNormalization": "La normalización del JSON-LD ha fallado",
      "foundUnmappedFields": "Se han encontrado campos no mapeados durante la normalización de JSON-LD",
      "ensureHashesEqual": "La cadena binaria calculada no corresponde con la cadena binaria remota",
      "ensureIssuerSignature": "La llave del emisor no corresponde con la dirección obtenida",
      "ensureMerkleRootEqual": "La raíz Merkle no corresponde con la cadena binaria remota",
      "ensureNotExpired": "Este certificado ha expirado",
      "getCaseInsensitiveKey": "La dirección emisora no era considerada válida cuando la transacción ocurrió",
      "ensureValidReceipt": "El recibo está malformado. Hubo un problema navegando el árbol Merkle en el recibo",
      "invalidMerkleReceipt": "Recibo Merkle inválido. La cadena binaria de prueba no corresponde con la raíz Merkle",
      "isTransactionIdValid": "No se puede verificar este certificado sin una identificación de transacción que sirva como comparación"
    }
  },
  "mt": {
    "steps": {
      "formatValidationLabel": "Validazzjoni tal-format",
      "formatValidationLabelPending": "Il-format qed jiġi vvalidat",
      "hashComparisonLabel": "Paragun tal-Hash",
      "hashComparisonLabelPending": "Il-hash qed jiġi pparagunat",
      "statusCheckLabel": "Status check",
      "statusCheckLabelPending": "Ir-record status qed jiġi ċċekkjat"
    },
    "subSteps": {
      "getTransactionIdLabel": "Ikseb l-ID ta' tranżazzjoni",
      "getTransactionIdLabelPending": "L-ID ta' tranżazzjoni qed tiġi mniżżla",
      "computeLocalHashLabel": "Ikkalkula l-hash lokali",
      "computeLocalHashLabelPending": "Il-hash lokali qed jiġi kkalkulat",
      "fetchRemoteHashLabel": "Fittex ir-remote hash",
      "fetchRemoteHashLabelPending": "Ir-remote hash qed jiġi mfittex",
      "getIssuerProfileLabel": "Ikseb il-profil tal-emittent",
      "getIssuerProfileLabelPending": "Il-profil tal-emittent qed jiġi mniżżel",
      "parseIssuerKeysLabel": "Estratta ċ-ċwievet tal-emittent",
      "parseIssuerKeysLabelPending": "Iċ-ċwievet tal-emittent qed jiġu estratti",
      "compareHashesLabel": "Ikkumpara l-hashes",
      "compareHashesLabelPending": "Il-hashes qed jiġu kkomparati",
      "checkMerkleRootLabel": "Iċċekkja l-Merkle Root",
      "checkMerkleRootLabelPending": "Il-Merkle Root Qed Tiġi Ċċekkjata",
      "checkReceiptLabel": "Iċċekkja l-Irċevuta",
      "checkReceiptLabelPending": "L-Irċevuta Qed Tiġi Ċċekkjata",
      "checkIssuerSignatureLabel": "Iċċekkja l-Firma tal-Emittent",
      "checkIssuerSignatureLabelPending": "Il-Firma tal-Emittent Qed Tiġi Ċċekkjata",
      "checkAuthenticityLabel": "Iċċekkja l-Awtentiċità",
      "checkAuthenticityLabelPending": "L-Awtentiċità Qed Tiġi Ċċekkjata",
      "checkRevokedStatusLabel": "Iċċekkja l-Istatus Revokat",
      "checkRevokedStatusLabelPending": "L-Istatus Revokat Qed Jiġi Ċċekkjat",
      "checkExpiresDateLabel": "Iċċekkja d-Data ta' Skadenza",
      "checkExpiresDateLabelPending": "Id-Data ta' Skadenza Qed Tiġi Ċċekkjata"
    },
    "revocation": {
      "preReason": "Raġuni mogħtija:",
      "reason": "Dan iċ-ċertifikat ġie revokat mill-emittent."
    },
    "success": {
      "mocknet": "Dan il-mock Blockcert għadda mill-verifiki kollha. Il-Mocknet mode jintuża biss sabiex l-emittenti jittestjaw il-workflow lokalment.",
      "blockchain": "Suċċess"
    },
    "errors": {
      "certificateNotValid": "Dan mhux ċertifikat validu",
      "getChain": "Iċ-chain value ma ntgħarafx",
      "getTransactionId": "Dan iċ-ċertifikat ma jistax jiġi vverifikat mingħajr ID ta' tranżazzjoni mqabbla miegħu",
      "getIssuerProfile": "Mhux possibbli jinkiseb il-profil tal-emittent",
      "getRevokedAssertions": "Mhux possibbli jinkisbu dikjarazzjonijiet revokati",
      "lookForTxInvalidChain": "Chain invalidu; BlockchainExplorers mhux qed isib chain magħrufa",
      "lookForTxInvalidAppConfig": "Konfigurazzjoni tal-applikazzjoni invalida; Iċċekkja l-valur konfigurattiv f' CONFIG.MinimumBlockchainExplorers",
      "lookForTxCouldNotConfirm": "It-tranżazzjoni ma setgħetx tiġi kkonferma. L-ebda blockchain apis ma rritorna rispons. Dan jista' jkun minħabba limitazzjoni tar-rata",
      "lookForTxDifferentAddresses": "L-indirizzi tal-ħruġ mibgħuta lura mill-blockchain APIs kienu differenti",
      "lookForTxDifferentRemoteHashes": "Ir-remote hashes mibgħuta lura mill-blockchain APIs kienu differenti",
      "parseIssuerKeys": "Ma jistax jiġi estratt JSON mid-data tal-identifikazzjoni tal-emittent",
      "getBlockcypherFetcher": "Mhux possibbli jinkiseb ir-remote hash",
      "getChainSoFetcher": "Mhux possibbli jinkiseb ir-remote hash",
      "parseBlockCypherResponse": "In-numru ta' konfermi tat-tranżazzjonijiet kienu inqas mill-minimu meħtieġ, skont Blockcypher API",
      "parseChainSoResponse": "In-numru ta' konfermi tat-tranżazzjonijiet kienu inqas mill-minimu meħtieġ, skont Chain.so API",
      "checkEtherScanConfirmations": "In-numru ta' konfermi tat-tranżazzjonijiet kienu inqas mill-minimu meħtieġ, skont EtherScan API",
      "couldNotConfirmTx": "Ma setgħetx tiġi kkonfermata t-tranżazzjoni",
      "failedJsonLdNormalization": "In-normalizzazzjoni ta' JSON-LD ma rnexxietx",
      "foundUnmappedFields": "Instabu unmapped fields matul in-normalizzazzjoni JSON-LD",
      "ensureHashesEqual": "Il-hash ikkalkulat ma jikkorrispondix mar-remote hash",
      "ensureIssuerSignature": "Iċ-ċavetta tal-emittent ma taqbilx mal-indirizz derivat",
      "ensureMerkleRootEqual": "Merkle root ma taqbilx mar-remote hash",
      "ensureNotExpired": "Dan iċ-ċertifikat skada",
      "getCaseInsensitiveKey": "It-tranżazzjoni seħħet fi żmiem meta l-indirizz tal-ħruġ ma tqiesx validu",
      "ensureValidReceipt": "L-irċevuta hija malformata. Kien hemm problema fin-navigazzjoni tal-merkle tree fl-irċevuta",
      "invalidMerkleReceipt": "Irċevuta Merkle invalida. Il-proof hash ma kienx jaqbel mal-Merkle root",
      "isTransactionIdValid": "Dan iċ-ċertifikat ma jistax jiġi vverifikat mingħajr ID ta' tranżazzjoni mqabbla miegħu"
    }
  },
  "it-IT": {
    "steps": {
      "formatValidationLabel": "Convalidare formato",
      "formatValidationLabelPending": "Convalida formato",
      "hashComparisonLabel": "Confrontare hash",
      "hashComparisonLabelPending": "Confronta hash",
      "statusCheckLabel": "Verificare stato",
      "statusCheckLabelPending": "Verifica stato del record"
    },
    "subSteps": {
      "getTransactionIdLabel": "Ottenere ID transazione",
      "getTransactionIdLabelPending": "Ottieni ID transazione",
      "computeLocalHashLabel": "Calcolare hash locale",
      "computeLocalHashLabelPending": "Calcola hash locale",
      "fetchRemoteHashLabel": "Recuperare hash remoto",
      "fetchRemoteHashLabelPending": "Recupera hash remoto",
      "getIssuerProfileLabel": "Ottenere profilo issuer",
      "getIssuerProfileLabelPending": "Ottieni profilo issuer",
      "parseIssuerKeysLabel": "Analizzare chiavi issuer",
      "parseIssuerKeysLabelPending": "Analizza chiavi issuer",
      "compareHashesLabel": "Confrontare gli hash",
      "compareHashesLabelPending": "Confronto hash",
      "checkMerkleRootLabel": "Controllare radice di Merkle",
      "checkMerkleRootLabelPending": "Controllo radice di Merkle",
      "checkReceiptLabel": "Verificare ricevuta",
      "checkReceiptLabelPending": "Verifica ricevuta",
      "checkIssuerSignatureLabel": "Verificare firma Issuer",
      "checkIssuerSignatureLabelPending": "Verifica firma Issuer",
      "checkAuthenticityLabel": "Verificare autenticità",
      "checkAuthenticityLabelPending": "Verifica autenticità",
      "checkRevokedStatusLabel": "Verificare stato revocato",
      "checkRevokedStatusLabelPending": "Verifica stato revocato",
      "checkExpiresDateLabel": "Verificare data di scadenza",
      "checkExpiresDateLabelPending": "Verifica data di scadenza"
    },
    "revocation": {
      "preReason": "Motivo indicato:",
      "reason": "Questo certificato è stato revocato dall'emittente."
    },
    "success": {
      "mocknet": "Questo Blockcert simulato ha superato tutti i controlli. La modalità Mocknet è utilizzata solo dagli emittenti per testare il loro flusso di lavoro localmente. Questo Blockcert non è stato registrato su una blockchain e non dovrebbe essere considerato un Blockcert verificato.",
      "blockchain": "Successo"
    },
    "errors": {
      "certificateNotValid": "Questo non è un certificato valido",
      "getChain": "Il valore della catena non è stato riconosciuto",
      "getTransactionId": "Impossibile verificare questo certificato senza un ID transazione da confrontare.",
      "getIssuerProfile": "Impossibile ottenere il profilo dell'emittente",
      "getRevokedAssertions": "Impossibile ottenere le asserzioni di revoca",
      "lookForTxInvalidChain": "Catena non valida; non mappa BlockchainExplorers noti.",
      "lookForTxInvalidAppConfig": "Configurazione dell'applicazione non valida, verificare il valore di configurazione di CONFIG.MinimumBlockchainExplorers",
      "lookForTxCouldNotConfirm": "Impossibile confermare la transazione. Nessuna API blockchain ha risposto. Potrebbe essere a causa della limitazione della velocità.",
      "lookForTxDifferentAddresses": "Gli indirizzi di emissione restituiti dalle API blockchain erano diversi",
      "lookForTxDifferentRemoteHashes": "Gli hash remoti restituiti dalle API blockchain erano diversi",
      "parseIssuerKeys": "Impossibile analizzare JSON dai dati di identificazione dell'emittente.",
      "getBlockcypherFetcher": "Impossibile ottenere l'hash remoto",
      "getChainSoFetcher": "Impossibile ottenere l'hash remoto",
      "parseBlockCypherResponse": "Il numero di conferme delle transazioni era inferiore al minimo richiesto, secondo l'API Blockcypher",
      "parseChainSoResponse": "Il numero di conferme delle transazioni era inferiore al minimo richiesto, secondo l'API Chain.so",
      "checkEtherScanConfirmations": "Il numero di conferme delle transazioni era inferiore al minimo richiesto, secondo l'API EtherScan",
      "couldNotConfirmTx": "Impossibile confermare la transazione",
      "failedJsonLdNormalization": "Normalizzazione JSON-LD fallita",
      "foundUnmappedFields": "Campi non mappati trovati durante la normalizzazione JSON-LD",
      "ensureHashesEqual": "L'hash calcolato non corrisponde all'hash remoto",
      "ensureIssuerSignature": "La chiave dell'issuer non corrisponde all'indirizzo derivato.",
      "ensureMerkleRootEqual": "La radice di Merkle non corrisponde all'hash remoto.",
      "ensureNotExpired": "Questo certificato è scaduto.",
      "getCaseInsensitiveKey": "La transazione è avvenuta nel momento in cui l'indirizzo di emissione non era considerato valido.",
      "ensureValidReceipt": "La ricevuta è malformata. C'è stato un problema nella navigazione dell'albero di Merkle nella ricevuta.",
      "invalidMerkleReceipt": "Ricevuta Merkle non valida. L'hash di prova non corrisponde alla radice di Merkle",
      "isTransactionIdValid": "Impossibile verificare questo certificato senza un ID transazione da confrontare."
    }
  },
  "ja": {
    "steps": {
      "formatValidationLabel": "フォーマットの検証",
      "formatValidationLabelPending": "フォーマットを検証しています",
      "hashComparisonLabel": "ハッシュの照合",
      "hashComparisonLabelPending": "ハッシュを照合しています",
      "statusCheckLabel": "ステータスの確認",
      "statusCheckLabelPending": "ステータスを確認しています"
    },
    "subSteps": {
      "getTransactionIdLabel": "取引IDの取得",
      "getTransactionIdLabelPending": "取引IDを取得しています",
      "computeLocalHashLabel": "ローカルハッシュの算出",
      "computeLocalHashLabelPending": "ローカルハッシュを算出しています",
      "fetchRemoteHashLabel": "リモートハッシュのフェッチ",
      "fetchRemoteHashLabelPending": "リモートハッシュをフェッチしています",
      "getIssuerProfileLabel": "発行者プロフィールの取得",
      "getIssuerProfileLabelPending": "発行者プロフィールを取得しています",
      "parseIssuerKeysLabel": "発行者の鍵のパース",
      "parseIssuerKeysLabelPending": "発行者の鍵をパースしています",
      "compareHashesLabel": "ハッシュの照合",
      "compareHashesLabelPending": "ハッシュを照合しています",
      "checkMerkleRootLabel": "Merkle Rootの確認",
      "checkMerkleRootLabelPending": "Merkle Rootを確認しています",
      "checkReceiptLabel": "レシートの確認",
      "checkReceiptLabelPending": "レシートを確認しています",
      "checkIssuerSignatureLabel": "発行者の署名の確認",
      "checkIssuerSignatureLabelPending": "発行者の署名を確認しています",
      "checkAuthenticityLabel": "真正性の確認",
      "checkAuthenticityLabelPending": "真正性を確認しています",
      "checkRevokedStatusLabel": "取消ステータスの確認",
      "checkRevokedStatusLabelPending": "取消ステータスを確認しています",
      "checkExpiresDateLabel": "有効期限の確認",
      "checkExpiresDateLabelPending": "有効期限を確認しています"
    },
    "revocation": {
      "preReason": "理由：",
      "reason": "この証明書は発行者によって取り消されました。"
    },
    "success": {
      "mocknet": "この模擬Blockcertは全てのチェックを通過しました。Mocknetモードは発行者がローカル環境でワークフローを確認するためのものです。このBlockcertはブロックチェーンに記録されていなく、認証済みのBlockcertとして扱われません。",
      "blockchain": "成功"
    },
    "errors": {
      "certificateNotValid": "この証明書は有効ではありません",
      "getChain": "チェーンの値を認識できませんでした",
      "getTransactionId": "照合のための取引IDがないため、この証明書を認証できません。",
      "getIssuerProfile": "発行者プロフィールを取得できません",
      "getRevokedAssertions": "取消assertionsを取得できません",
      "lookForTxInvalidChain": "チェーンが無効です。既知のBlockchainExplorersにマップできません。",
      "lookForTxInvalidAppConfig": "アプリケーション設定が無効です。CONFIG.MinimumBlockchainExplorersの設定値を確認して下さい。",
      "lookForTxCouldNotConfirm": "取引を確認できませんでした。全てのブロックチェーンAPIが返信しませんでした。 レート制限が原因になっている可能性があります。",
      "lookForTxDifferentAddresses": "ブロックチェーンAPIから返された発行者アドレスが異なっていました",
      "lookForTxDifferentRemoteHashes": "ブロックチェーンAPIから返されたリモートハッシュが異なっていました",
      "parseIssuerKeys": "発行者識別データからJSONをパースできません",
      "getBlockcypherFetcher": "リモートハッシュを取得できません",
      "getChainSoFetcher": "リモートハッシュを取得できません",
      "parseBlockCypherResponse": "Blockcypher APIによると、必要最小限の取引確認の数に達しませんでした",
      "parseChainSoResponse": "Chain.so APIによると、必要最小限の取引確認の数に達しませんでした",
      "checkEtherScanConfirmations": "EtherScan APIによると、必要最小限の取引確認の数に達しませんでした",
      "couldNotConfirmTx": "取引を確認できませんでした",
      "failedJsonLdNormalization": "JSON-LDの正規化に失敗しました",
      "foundUnmappedFields": "JSON-LDの正規化時にマップされていないフィールドを検出しました",
      "ensureHashesEqual": "算出されたハッシュがリモートハッシュと一致しませんでした",
      "ensureIssuerSignature": "発行者の鍵が得られたアドレスと一致しませんでした",
      "ensureMerkleRootEqual": "Merkle rootがリモートハッシュと一致しませんでした",
      "ensureNotExpired": "この証明書の有効期限が切れています",
      "getCaseInsensitiveKey": "取引が発行アドレスの有効期間外に行われました",
      "ensureValidReceipt": "レシートが異常です。レシート内のMerkle treeを辿る際に問題が発生しました。",
      "invalidMerkleReceipt": "Merkleレシートが無効です。証明ハッシュがMerkle rootと一致しませんでした。",
      "isTransactionIdValid": "照合するための取引IDがないため、この証明書を認証できません。"
    }
  }
}
